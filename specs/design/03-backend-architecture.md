# 3. Backend Architecture: The Distributed Agent Mesh

## 3.1 High-Level Pattern: Microservices vs. Modulith
Given the disparate nature of the workloads—standard API requests (I/O bound) vs. parsing/scraping (CPU/Memory bound) vs. AI analysis (GPU/Tensor bound)—a Microservices Architecture is mandated. A monolithic approach would risk the "noisy neighbor" problem, where a heavy parsing job degrades the latency of the API Gateway.

**Table 2: Service Decomposition and Technology Stack**

| Service Domain            | Role                                            | Technology Stack                  | Scaling Strategy                                        |
| ------------------------- | ----------------------------------------------- | --------------------------------- | ------------------------------------------------------- |
| **Gateway Service (BFF)** | Authentication, Routing, Response Aggregation   | Node.js / NestJS                  | Horizontal (Stateless) behind Load Balancer.            |
| **Ingest Agent**          | External API Interaction, Rate Limit Management | Go (Golang)                       | Horizontal Worker Pool; optimized for high concurrency. |
| **Toon-Parser**           | Unstructured Data Scraping, HTML Parsing        | Python (Playwright/BeautifulSoup) | Queue-Based; Containerized Replicas.                    |
| **Neural-Analyst**        | Sentiment Analysis, Score Generation            | Python (PyTorch/Transformers)     | GPU-optimized instances; Batch processing.              |
| **Vault Service**         | Cryptographic Key Management                    | Go (Golang)                       | Vertical scaling; Security-hardened environment.        |

## 3.2 The API Gateway (NestJS)
The Gateway acts as the single entry point for the Angular frontend. We select NestJS for this layer due to its affinity with Angular (TypeScript, Decorators, Dependency Injection), allowing for shared DTOs (Data Transfer Objects) between frontend and backend.

**Responsibilities:**
- **Protocol Translation**: Converts external REST requests into internal gRPC or Redis Pub/Sub messages.
- **Authentication**: Validates JWTs generated by the Auth Service.
- **Request Composition**: Aggregates data from the Neural-Analyst (sentiment) and Ingest Agent (price) into a single response payload for the UI.

### 3.2.1 Gateway APIs (NestJS Controller)
**File**: `src/modules/dashboard/dashboard.controller.ts`
```typescript
@Controller('api/v1')
@UseGuards(JwtAuthGuard)
export class DashboardController {
  constructor(
    private readonly portfolioService: PortfolioService,
    private readonly agentClient: AgentGrpcClient // gRPC connection to Go service
  ) {}

  // Populates Image 1 (Portfolio)
  @Get('portfolio/summary')
  async getPortfolioSummary(@User() user: UserEntity) {
    // Returns { totalValue, dayChange, allocationPieChartData, positionsTable }
    return this.portfolioService.getSummary(user.id);
  }

  // Populates Image 2 (Stock Detail)
  @Get('ticker/:symbol/deep-dive')
  async getTickerDeepDive(@Param('symbol') symbol: string) {
    // Fetches OHLCV from TimescaleDB
    // Fetches latest AI Rating from Postgres
    return this.portfolioService.getTickerDetails(symbol);
  }

  // Trigger AI Agent (The "Twist")
  @Post('agent/analyze')
  async triggerAgent(@Body() body: TriggerAnalysisDto) {
    // 1. Check if user has credits or personal keys
    // 2. Dispatch job to Golang Microservice via gRPC
    return this.agentClient.dispatchJob({
      symbol: body.ticker,
      depth: body.depth,
      userId: body.userId
    });
  }
}
```

## 3.3 The Ingest Agent (Go) & Distributed Rate Limiting
The Ingest Agent is the workhorse of the BYOK model. It requires the high concurrency capabilities of Go (goroutines) to manage thousands of simultaneous, blocked network requests waiting on rate limit timers.

**The "Community Mesh" Algorithm:**
1. **Request Arrival**: A user requests data for "NVDA".
2. **Key Retrieval**: The agent retrieves the user's encrypted key from the Vault.
3. **Limit Check**: The agent checks a Redis-backed Token Bucket specific to that user's key.
4. **If Tokens Available**: The request executes immediately.
5. **If Bucket Empty**: The agent checks the Community Cache (TimescaleDB).
   - If fresh data (< 1 min old) exists (fetched by another user), it is returned immediately. This effectively "crowdsources" the bandwidth.
   - If no cache exists, the request enters a Priority Queue, waiting for the user's token bucket to refill.

## 3.4 DTOs (Data Transfer Objects) with Validation
We use `class-validator` and `class-transformer` in NestJS to ensure data integrity before it hits the logic layer.

**File**: `src/modules/agents/dto/trigger-analysis.dto.ts`
```typescript
import { IsString, IsNotEmpty, IsEnum, IsOptional, IsBoolean } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export enum AnalysisDepth {
  LITE = 'lite',       // Just price + basic sentiment
  DEEP = 'deep',       // Full web crawl + PDF report
  INSIDER = 'insider'  // Scrape reddit/stocktwits (Community Agent)
}

export class TriggerAnalysisDto {
  @ApiProperty({ example: 'NVDA', description: 'Stock Ticker Symbol' })
  @IsString()
  @IsNotEmpty()
  ticker: string;

  @ApiProperty({ enum: AnalysisDepth, default: AnalysisDepth.LITE })
  @IsEnum(AnalysisDepth)
  depth: AnalysisDepth;

  @ApiProperty({ description: 'Use my own API keys (BYOK) for higher limits', default: false })
  @IsBoolean()
  @IsOptional()
  use_personal_keys?: boolean;
}
```

**File**: `src/modules/stocks/dto/stock-insight.dto.ts` (Response DTO for Image 2 data)
```typescript
export class StockInsightDto {
  symbol: string;
  price: number;
  
  @ApiProperty({ description: '0-100 score from Image 3 Gauge' })
  neural_rating: number;
  
  @ApiProperty({ description: 'AI generated bullet points' })
  smart_summary: {
    news_sentiment: string;
    analyst_consensus: string;
    technical_outlook: string;
  };

  @ApiProperty({ description: 'Upcoming events like Earnings' })
  next_event: {
    date: Date;
    type: string;
  };
}
```
